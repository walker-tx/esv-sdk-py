"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from esv_sdk import models, utils
from esv_sdk._hooks import HookContext
from esv_sdk.types import OptionalNullable, UNSET
from esv_sdk.utils import get_security_from_env
import httpx
from jsonpath import JSONPath
from typing import Any, Dict, Mapping, Optional


class Passages(BaseSDK):
    def get_html(
        self,
        *,
        query: str,
        include_passage_references: Optional[bool] = True,
        include_verse_numbers: Optional[bool] = True,
        include_first_verse_numbers: Optional[bool] = True,
        include_footnotes: Optional[bool] = True,
        include_footnote_body: Optional[bool] = True,
        include_headings: Optional[bool] = True,
        include_short_copyright: Optional[bool] = False,
        include_copyright: Optional[bool] = False,
        include_passage_horizontal_lines: Optional[bool] = False,
        include_heading_horizontal_lines: Optional[bool] = False,
        horizontal_line_length: Optional[int] = 55,
        include_selahs: Optional[bool] = True,
        include_css_link: Optional[bool] = True,
        inline_styles: Optional[bool] = False,
        wrapping_div: Optional[bool] = True,
        div_classes: Optional[str] = "esv",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PassageResponse:
        r"""Get Bible passage HTML

        Returns Bible passage text with HTML formatting
        https://api.esv.org/docs/passage-html/ - Esv.org API Docs for `/v3/passages/html`

        :param query: Bible passage reference (e.g., \"John 3:16\" or \"43011016\")
        :param include_passage_references: Include passage references before passages
        :param include_verse_numbers: Include verse numbers
        :param include_first_verse_numbers: Include the verse number for the first verse of a chapter
        :param include_footnotes: Include callouts to footnotes in the text.
        :param include_footnote_body: Include footnote body content
        :param include_headings: Include passage headings
        :param include_short_copyright: Include a short copyright notice
        :param include_copyright: Include the full copyright notice
        :param include_passage_horizontal_lines: Include horizontal lines between passages
        :param include_heading_horizontal_lines: Include horizontal lines under headings
        :param horizontal_line_length: Length of horizontal lines
        :param include_selahs: Include \"Selah\" in passage text
        :param include_css_link: Include a link to the ESV API CSS file
        :param inline_styles: Include inline styles on HTML elements
        :param wrapping_div: Wrap the HTML output in a div with class=\"esv\"
        :param div_classes: Classes to add to the wrapping div
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetPassageHTMLRequest(
            query=query,
            include_passage_references=include_passage_references,
            include_verse_numbers=include_verse_numbers,
            include_first_verse_numbers=include_first_verse_numbers,
            include_footnotes=include_footnotes,
            include_footnote_body=include_footnote_body,
            include_headings=include_headings,
            include_short_copyright=include_short_copyright,
            include_copyright=include_copyright,
            include_passage_horizontal_lines=include_passage_horizontal_lines,
            include_heading_horizontal_lines=include_heading_horizontal_lines,
            horizontal_line_length=horizontal_line_length,
            include_selahs=include_selahs,
            include_css_link=include_css_link,
            inline_styles=inline_styles,
            wrapping_div=wrapping_div,
            div_classes=div_classes,
        )

        req = self._build_request(
            method="GET",
            path="/passage/html/",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getPassageHtml",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.PassageResponse)
        if utils.match_response(http_res, ["400", "401"], "application/json"):
            response_data = utils.unmarshal_json(http_res.text, models.ErrorData)
            raise models.Error(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_html_async(
        self,
        *,
        query: str,
        include_passage_references: Optional[bool] = True,
        include_verse_numbers: Optional[bool] = True,
        include_first_verse_numbers: Optional[bool] = True,
        include_footnotes: Optional[bool] = True,
        include_footnote_body: Optional[bool] = True,
        include_headings: Optional[bool] = True,
        include_short_copyright: Optional[bool] = False,
        include_copyright: Optional[bool] = False,
        include_passage_horizontal_lines: Optional[bool] = False,
        include_heading_horizontal_lines: Optional[bool] = False,
        horizontal_line_length: Optional[int] = 55,
        include_selahs: Optional[bool] = True,
        include_css_link: Optional[bool] = True,
        inline_styles: Optional[bool] = False,
        wrapping_div: Optional[bool] = True,
        div_classes: Optional[str] = "esv",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PassageResponse:
        r"""Get Bible passage HTML

        Returns Bible passage text with HTML formatting
        https://api.esv.org/docs/passage-html/ - Esv.org API Docs for `/v3/passages/html`

        :param query: Bible passage reference (e.g., \"John 3:16\" or \"43011016\")
        :param include_passage_references: Include passage references before passages
        :param include_verse_numbers: Include verse numbers
        :param include_first_verse_numbers: Include the verse number for the first verse of a chapter
        :param include_footnotes: Include callouts to footnotes in the text.
        :param include_footnote_body: Include footnote body content
        :param include_headings: Include passage headings
        :param include_short_copyright: Include a short copyright notice
        :param include_copyright: Include the full copyright notice
        :param include_passage_horizontal_lines: Include horizontal lines between passages
        :param include_heading_horizontal_lines: Include horizontal lines under headings
        :param horizontal_line_length: Length of horizontal lines
        :param include_selahs: Include \"Selah\" in passage text
        :param include_css_link: Include a link to the ESV API CSS file
        :param inline_styles: Include inline styles on HTML elements
        :param wrapping_div: Wrap the HTML output in a div with class=\"esv\"
        :param div_classes: Classes to add to the wrapping div
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetPassageHTMLRequest(
            query=query,
            include_passage_references=include_passage_references,
            include_verse_numbers=include_verse_numbers,
            include_first_verse_numbers=include_first_verse_numbers,
            include_footnotes=include_footnotes,
            include_footnote_body=include_footnote_body,
            include_headings=include_headings,
            include_short_copyright=include_short_copyright,
            include_copyright=include_copyright,
            include_passage_horizontal_lines=include_passage_horizontal_lines,
            include_heading_horizontal_lines=include_heading_horizontal_lines,
            horizontal_line_length=horizontal_line_length,
            include_selahs=include_selahs,
            include_css_link=include_css_link,
            inline_styles=inline_styles,
            wrapping_div=wrapping_div,
            div_classes=div_classes,
        )

        req = self._build_request_async(
            method="GET",
            path="/passage/html/",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getPassageHtml",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.PassageResponse)
        if utils.match_response(http_res, ["400", "401"], "application/json"):
            response_data = utils.unmarshal_json(http_res.text, models.ErrorData)
            raise models.Error(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def search(
        self,
        *,
        query: str,
        page_size: Optional[int] = 20,
        page: Optional[int] = 1,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.SearchPassagesResponse]:
        r"""Search Bible passages

        Returns search results for Bible passages based on the provided query
        https://api.esv.org/docs/passage-search/ - Esv.org API Docs for `/v3/passage/search`

        :param query: The text to search for
        :param page_size: Number of results to return per page
        :param page: Page number to return
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SearchPassagesRequest(
            query=query,
            page_size=page_size,
            page=page,
        )

        req = self._build_request(
            method="GET",
            path="/passage/search/",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="searchPassages",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.SearchPassagesResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page if not request.page is None else 1
            next_page = page + 1

            num_pages = JSONPath("$.total_pages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.search(
                query=query,
                page_size=page_size,
                page=next_page,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.SearchPassagesResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.SearchPassagesResponseBody
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["400", "401"], "application/json"):
            response_data = utils.unmarshal_json(http_res.text, models.ErrorData)
            raise models.Error(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def search_async(
        self,
        *,
        query: str,
        page_size: Optional[int] = 20,
        page: Optional[int] = 1,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.SearchPassagesResponse]:
        r"""Search Bible passages

        Returns search results for Bible passages based on the provided query
        https://api.esv.org/docs/passage-search/ - Esv.org API Docs for `/v3/passage/search`

        :param query: The text to search for
        :param page_size: Number of results to return per page
        :param page: Page number to return
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SearchPassagesRequest(
            query=query,
            page_size=page_size,
            page=page,
        )

        req = self._build_request_async(
            method="GET",
            path="/passage/search/",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="searchPassages",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.SearchPassagesResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page if not request.page is None else 1
            next_page = page + 1

            num_pages = JSONPath("$.total_pages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.search(
                query=query,
                page_size=page_size,
                page=next_page,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.SearchPassagesResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.SearchPassagesResponseBody
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["400", "401"], "application/json"):
            response_data = utils.unmarshal_json(http_res.text, models.ErrorData)
            raise models.Error(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_audio(
        self,
        *,
        query: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> httpx.Response:
        r"""Get Bible passage audio

        Returns audio file for Bible passages based on the provided query
        https://api.esv.org/docs/passage-audio/ - Esv.org API Docs for `/v3/passage/audio`

        :param query: Bible passage reference (e.g., \"John 3:16\" or \"43011016\")
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetPassageAudioRequest(
            query=query,
        )

        req = self._build_request(
            method="GET",
            path="/passage/audio/",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="audio/mpeg",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getPassageAudio",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "audio/mpeg"):
            return http_res
        if utils.match_response(http_res, ["400", "401"], "application/json"):
            http_res_text = utils.stream_to_text(http_res)
            response_data = utils.unmarshal_json(http_res_text, models.ErrorData)
            raise models.Error(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_audio_async(
        self,
        *,
        query: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> httpx.Response:
        r"""Get Bible passage audio

        Returns audio file for Bible passages based on the provided query
        https://api.esv.org/docs/passage-audio/ - Esv.org API Docs for `/v3/passage/audio`

        :param query: Bible passage reference (e.g., \"John 3:16\" or \"43011016\")
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetPassageAudioRequest(
            query=query,
        )

        req = self._build_request_async(
            method="GET",
            path="/passage/audio/",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="audio/mpeg",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getPassageAudio",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "audio/mpeg"):
            return http_res
        if utils.match_response(http_res, ["400", "401"], "application/json"):
            http_res_text = await utils.stream_to_text_async(http_res)
            response_data = utils.unmarshal_json(http_res_text, models.ErrorData)
            raise models.Error(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_text(
        self,
        *,
        query: str,
        include_passage_references: Optional[bool] = True,
        include_verse_numbers: Optional[bool] = True,
        include_first_verse_numbers: Optional[bool] = True,
        include_footnotes: Optional[bool] = True,
        include_footnote_body: Optional[bool] = True,
        include_headings: Optional[bool] = True,
        include_short_copyright: Optional[bool] = False,
        include_copyright: Optional[bool] = False,
        include_passage_horizontal_lines: Optional[bool] = False,
        include_heading_horizontal_lines: Optional[bool] = False,
        horizontal_line_length: Optional[int] = 55,
        include_selahs: Optional[bool] = True,
        indent_using: Optional[models.IndentUsing] = models.IndentUsing.SPACE,
        indent_paragraphs: Optional[int] = 2,
        indent_poetry: Optional[int] = 2,
        indent_poetry_lines: Optional[int] = 4,
        indent_declares: Optional[int] = 40,
        indent_psalm_doxology: Optional[int] = 30,
        line_length: Optional[int] = 0,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PassageResponse:
        r"""Get Bible passage text

        Returns Bible passage text based on the provided query parameters
        https://api.esv.org/docs/passage-text/ - Esv.org API Docs for `/v3/passages/text`

        :param query: Bible passage reference (e.g., \"John 3:16\" or \"43011016\")
        :param include_passage_references: Include passage references before passages
        :param include_verse_numbers: Include verse numbers
        :param include_first_verse_numbers: Include the verse number for the first verse of a chapter
        :param include_footnotes: Include callouts to footnotes in the text.
        :param include_footnote_body: Include footnote body content
        :param include_headings: Include passage headings
        :param include_short_copyright: Include a short copyright notice
        :param include_copyright: Include the full copyright notice
        :param include_passage_horizontal_lines: Include horizontal lines between passages
        :param include_heading_horizontal_lines: Include horizontal lines under headings
        :param horizontal_line_length: Length of horizontal lines
        :param include_selahs: Include \"Selah\" in passage text
        :param indent_using: Character to use for indentation
        :param indent_paragraphs: Number of indentation characters for paragraphs
        :param indent_poetry: Number of indentation characters for poetry
        :param indent_poetry_lines: Number of indentation characters for poetry lines
        :param indent_declares: Number of indentation characters for declares
        :param indent_psalm_doxology: Number of indentation characters for Psalm doxology
        :param line_length: Maximum line length
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetPassageTextRequest(
            query=query,
            include_passage_references=include_passage_references,
            include_verse_numbers=include_verse_numbers,
            include_first_verse_numbers=include_first_verse_numbers,
            include_footnotes=include_footnotes,
            include_footnote_body=include_footnote_body,
            include_headings=include_headings,
            include_short_copyright=include_short_copyright,
            include_copyright=include_copyright,
            include_passage_horizontal_lines=include_passage_horizontal_lines,
            include_heading_horizontal_lines=include_heading_horizontal_lines,
            horizontal_line_length=horizontal_line_length,
            include_selahs=include_selahs,
            indent_using=indent_using,
            indent_paragraphs=indent_paragraphs,
            indent_poetry=indent_poetry,
            indent_poetry_lines=indent_poetry_lines,
            indent_declares=indent_declares,
            indent_psalm_doxology=indent_psalm_doxology,
            line_length=line_length,
        )

        req = self._build_request(
            method="GET",
            path="/passage/text/",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getPassageText",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.PassageResponse)
        if utils.match_response(http_res, ["400", "401"], "application/json"):
            response_data = utils.unmarshal_json(http_res.text, models.ErrorData)
            raise models.Error(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_text_async(
        self,
        *,
        query: str,
        include_passage_references: Optional[bool] = True,
        include_verse_numbers: Optional[bool] = True,
        include_first_verse_numbers: Optional[bool] = True,
        include_footnotes: Optional[bool] = True,
        include_footnote_body: Optional[bool] = True,
        include_headings: Optional[bool] = True,
        include_short_copyright: Optional[bool] = False,
        include_copyright: Optional[bool] = False,
        include_passage_horizontal_lines: Optional[bool] = False,
        include_heading_horizontal_lines: Optional[bool] = False,
        horizontal_line_length: Optional[int] = 55,
        include_selahs: Optional[bool] = True,
        indent_using: Optional[models.IndentUsing] = models.IndentUsing.SPACE,
        indent_paragraphs: Optional[int] = 2,
        indent_poetry: Optional[int] = 2,
        indent_poetry_lines: Optional[int] = 4,
        indent_declares: Optional[int] = 40,
        indent_psalm_doxology: Optional[int] = 30,
        line_length: Optional[int] = 0,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PassageResponse:
        r"""Get Bible passage text

        Returns Bible passage text based on the provided query parameters
        https://api.esv.org/docs/passage-text/ - Esv.org API Docs for `/v3/passages/text`

        :param query: Bible passage reference (e.g., \"John 3:16\" or \"43011016\")
        :param include_passage_references: Include passage references before passages
        :param include_verse_numbers: Include verse numbers
        :param include_first_verse_numbers: Include the verse number for the first verse of a chapter
        :param include_footnotes: Include callouts to footnotes in the text.
        :param include_footnote_body: Include footnote body content
        :param include_headings: Include passage headings
        :param include_short_copyright: Include a short copyright notice
        :param include_copyright: Include the full copyright notice
        :param include_passage_horizontal_lines: Include horizontal lines between passages
        :param include_heading_horizontal_lines: Include horizontal lines under headings
        :param horizontal_line_length: Length of horizontal lines
        :param include_selahs: Include \"Selah\" in passage text
        :param indent_using: Character to use for indentation
        :param indent_paragraphs: Number of indentation characters for paragraphs
        :param indent_poetry: Number of indentation characters for poetry
        :param indent_poetry_lines: Number of indentation characters for poetry lines
        :param indent_declares: Number of indentation characters for declares
        :param indent_psalm_doxology: Number of indentation characters for Psalm doxology
        :param line_length: Maximum line length
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetPassageTextRequest(
            query=query,
            include_passage_references=include_passage_references,
            include_verse_numbers=include_verse_numbers,
            include_first_verse_numbers=include_first_verse_numbers,
            include_footnotes=include_footnotes,
            include_footnote_body=include_footnote_body,
            include_headings=include_headings,
            include_short_copyright=include_short_copyright,
            include_copyright=include_copyright,
            include_passage_horizontal_lines=include_passage_horizontal_lines,
            include_heading_horizontal_lines=include_heading_horizontal_lines,
            horizontal_line_length=horizontal_line_length,
            include_selahs=include_selahs,
            indent_using=indent_using,
            indent_paragraphs=indent_paragraphs,
            indent_poetry=indent_poetry,
            indent_poetry_lines=indent_poetry_lines,
            indent_declares=indent_declares,
            indent_psalm_doxology=indent_psalm_doxology,
            line_length=line_length,
        )

        req = self._build_request_async(
            method="GET",
            path="/passage/text/",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getPassageText",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.PassageResponse)
        if utils.match_response(http_res, ["400", "401"], "application/json"):
            response_data = utils.unmarshal_json(http_res.text, models.ErrorData)
            raise models.Error(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
